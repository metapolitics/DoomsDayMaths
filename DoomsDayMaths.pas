{*************************************************************}
{                                                             }
{                       TURBO PASCAL 7.0                      }
{ DOOMSDAYMATHS.PAS, PROGRAMMED BY CSWEETMAN                  }
{ LAST MODIFIED: 1630, 16 AUGUST 2004                         }
{ FINAL VERSION v.1.b                                         }
{ ----------------------------------------------------------- }
{ THIS GAME IS A EDUCATIONAL MATHEMATICS GAME, BASED FOR      }
{ PRIMARY SCHOOLERS, IT SAVES AND DISPLAYS HIGH SCORES, IT IS }
{ CHALLENGING WITH 3 LEVELS OF DIFFICULTY, THE GAME HAS SOME  }
{ ANIMATION IN IT, AND USES GRAPHICS MODE. THE GAME ALSO      }
{ PROVIDES CHEATS, AND A RESETING SCORES, THOUGH TO RESET     }
{ SCORES YOU MUST TYPE A PASSWORD IN                          }
{                                                             }
{*************************************************************}

{$R+} {RANGE CHECKING}
{$I-} {FILE CHECKING}
PROGRAM DOOMSDAYMATHS;
USES CRT, GRAPH, DOS;
{DECLARES USER-DEFINED-TYPE (UDT) OF SCORE_DETAILS}
TYPE
    SCORE_DETAILS = RECORD
                  NAME: STRING[20];
                  SCORE: INTEGER;
                  END;
    QUEST = RECORD
          QUESTION: STRING;
          ANSWER: INTEGER;
          END;
{GLOBAL VARIABLES}
VAR TOP_SCORES: ARRAY [1..11] OF SCORE_DETAILS;
    EASY_Q: ARRAY [1..20] OF QUEST;
    MED_Q: ARRAY [1..20] OF QUEST;
    HARD_Q: ARRAY [1..20] OF QUEST;
    GRMODE, GRDRIVER: INTEGER;
{DECLARES CONSTANT}
CONST
S_PATH= 'SCORES\SCORES.REC';
G_PATH= 'GRAPH3\';
{DIFFICULTY CONSTANTS}
EASY = 1;
MED = 2;
HARD = 3;
{TEXT FONT CONSTANTS}
DEFAULT_FONT = 0;
TRIPLEX_FONT = 1;
SMALL_FONT   = 2;
SANsSERIF_FONT = 3;
GOTHIC_FONT  = 4;
HORIZDIR     = 0;
VERTDIR      = 1;
{COLOR CONSTANTS}
BLINK        = 128;
BLACK        =  0;
BLUE         =  1;
GREEN        =  2;
CYAN         =  3;
RED          =  4;
MAGENTA      =  5;
BROWN        =  6;
LIGHTGRAY    =  7;
DARKGRAY     =  8;
LIGHTBLUE    =  9;
LIGHTGREEN   = 10;
LIGHTCYAN    = 11;
LIGHTRED     = 12;
LIGHTMAGENTA = 13;
YELLOW       = 14;
WHITE        = 15;
{FILL STYLE CONSTANTS}
EMPTYFILL    = 0;
SOLIDFILL    = 1;
LINEFILL     = 2;
LTSLASHFILL  = 3;
SLASHFILL    = 4;
BKSLASHFILL  = 5;
LTBKSLASHFILL= 6;
HATCHFILL    = 7;
XHATCHFILL   = 8;
INTERLEAVEFILL = 9;
WIDEDOTFILL  = 10;
CLOSEDOTFILL = 11;
{FORWARD CALLS}
PROCEDURE CLR_SCR; FORWARD;
PROCEDURE STAR_ANIMATION(X_DELAY,COLOR1,COLOR2: INTEGER); FORWARD;
PROCEDURE RESET_SCORES; FORWARD;
PROCEDURE BORDER(COLOR: INTEGER); FORWARD;
PROCEDURE INSTRUCTIONS; FORWARD;
PROCEDURE SPLASH_SCREEN(X_DELAY: INTEGER); FORWARD;
PROCEDURE DOOMSDAY_SCREEN(X_DELAY, Y_DELAY, STAR_DELAY, HZ: INTEGER); FORWARD;
PROCEDURE CREDITS(X_DELAY: INTEGER); FORWARD;
FUNCTION GET_POS(NAME1: STRING; SCORE1: INTEGER): INTEGER; FORWARD;
FUNCTION DIFFICULTY_SCREEN: INTEGER; FORWARD;
FUNCTION GET_NAME: STRING; FORWARD;
PROCEDURE GET_SCORES; FORWARD;
PROCEDURE BUBBLE_SORT_SCORES; FORWARD;
PROCEDURE SAVE_SCORES; FORWARD;
PROCEDURE HIGH_SCORES; FORWARD;
PROCEDURE SAVE_NEW_SCORE(NAME1: STRING; SCORE1: INTEGER); FORWARD;
PROCEDURE SAVE_DEFAULT_SCORES; FORWARD;
PROCEDURE VIEW_SCORE(SCORE: INTEGER; POS: STRING); FORWARD;
FUNCTION GET_PASSWORD: STRING; FORWARD;
PROCEDURE GENERATE_QUESTIONS; FORWARD;
PROCEDURE ERROR_MESSAGE; FORWARD;
FUNCTION ASK_QUESTION(QUESTION: STRING; ANSWER: INTEGER; DIFF, CUR_SKR: INTEGER): INTEGER; FORWARD;
PROCEDURE GAME; FORWARD;
PROCEDURE MAIN_MENU; FORWARD;


{**************************************}
{                CLR_SCR               }
{          CLEARS THE SCREEN           }
{**************************************}
PROCEDURE CLR_SCR;
BEGIN
     CLRSCR; {CLEARS THE SCREEN}
     SETFILLSTYLE(SOLIDFILL, BLACK); {CHANGES FILL SETTINGS TO SOLID BLACK}
     BAR(0,0,GETMAXX, GETMAXY); {APPLIES A BAR TO WHOLE SCREEN}
END; {PROCEDURE CLR_SCR}

{*************************************}
{             STAR_ANIMATION          }
{ PRODUCES A STAR ANIMATION USING 2   }
{ TRIANGLES                           }
{*************************************}
PROCEDURE STAR_ANIMATION(X_DELAY, COLOR1, COLOR2: INTEGER);
VAR K_PRESSED: BOOLEAN; {DECLARES TO TELL IF A KEY IS PRESSED}
    {TRIANGLE1 PROCEDURE DRAWS THE FIRST TRIANGLE}
    PROCEDURE TRIANGLE1(COLOR: INTEGER);
    VAR X,Y: INTEGER;
    BEGIN
         Y:= 340; {SETS THE FIRST Y POINT}
         FOR X:= 520 DOWNTO 440 DO
             BEGIN
                  PUTPIXEL(X,Y,COLOR); {FILLS INDIVIDUAL PIXELS}
                  Y:= Y + 1;
                  DELAY(X_DELAY);
             END;
         FOR X:= 440 TO 600 DO
             BEGIN
                  PUTPIXEL(X,420,COLOR); {FILLS PIXELS IN A STRAIGHT LINE}
                  DELAY(X_DELAY);
             END;
         Y:= 420; {SETS THE SECOND Y POINT}
         FOR X:= 600 DOWNTO 520 DO
             BEGIN
                  PUTPIXEL(X,Y,COLOR); {FILLS INDIVIDUAL PIXELS}
                  Y:= Y - 1;
                  DELAY(X_DELAY);
             END;
    END;
    {TRIANGLE2 PROCEDURE DRAWS THE SECOND TRIANGLE}
    PROCEDURE TRIANGLE2(COLOR: INTEGER);
    VAR X,Y: INTEGER;
    BEGIN
         Y:= 380; {SETS THE FIRST Y POINT}
         FOR X:= 440 TO 520 DO
             BEGIN
                  PUTPIXEL(X,Y,COLOR); {FILLS PIXELS INDIVIDUALLY}
                  Y:= Y + 1;
                  DELAY(X_DELAY);
             END;
         Y:= 460; {SETS THE SECOND Y POINT}
         FOR X:= 520 TO 600 DO
             BEGIN

                  PUTPIXEL(X,Y,COLOR); {FILLS PIXELS INDIVIDUALLY}
                  Y:= Y - 1;
                  DELAY(X_DELAY);
             END;
         FOR X:= 600 DOWNTO 440 DO
             BEGIN
                  PUTPIXEL(X,380,COLOR); {FILLS PIXELS BACK TO THE ORIGIN}
                  DELAY(X_DELAY);
             END;
    END;
    {ANIMATION PROCEDURE DRAWS BOTH TRIANGLES AND CHECKS IF KEY IS PRESSED}
    PROCEDURE ANIMATION;
    BEGIN
         TRIANGLE1(COLOR1); {DRAWS TRIANGLE1 IN COLOR1}
         IF KEYPRESSED THEN {IF A KEY WAS PRESSED, EXITS THE CURRENT PROCEDURE}
            BEGIN
                 K_PRESSED:= TRUE;
                 EXIT;
            END;
         TRIANGLE2(COLOR1); {DRAWS TRIANGLE2 IN COLOR1}
         IF KEYPRESSED THEN {IF A KEY WAS PRESSED, EXITS THE CURRENT PROCEDURE}
            BEGIN
                 K_PRESSED:= TRUE;
                 EXIT;
            END;
         TRIANGLE1(COLOR2); {DRAWS TRIANGLE1 IN COLOR2}
         IF KEYPRESSED THEN {IF A KEY WAS PRESSED, EXITS THE CURRENT PROCEDURE}
            BEGIN
                 K_PRESSED:= TRUE;
                 EXIT;
            END;
         TRIANGLE2(COLOR2); {DRAWS TRIANGLE2 IN COLOR2}
         IF KEYPRESSED THEN {IF A KEY WAS PRESSED, EXITS THE CURRENT PROCEDURE}
            BEGIN
                 K_PRESSED:= TRUE;
                 EXIT;
            END;

    END;
BEGIN
     K_PRESSED:= FALSE; {DECLARES A KEY HASNT BEEN PRESSED YET}
     REPEAT
           ANIMATION; {STARTS THE ANIMATION PROCEDURE, DRAWING THE TRIANGLES}
     UNTIL K_PRESSED; {UNTIL A KEY HAS BEEN PRESSED}
END; {PROCEDURE STAR_ANIMATION}

{*************************************}
{            BORDER                   }
{     DRAWS A BORDER IN (COLOR)       }
{*************************************}
PROCEDURE BORDER(COLOR:INTEGER);
BEGIN
     SETCOLOR(COLOR); {SETS THE COLOR TO COLOR}
     RECTANGLE(0,0,GETMAXX,GETMAXY); {DRAWS A FULL SCREEN BORDER}
END; {PROCEDURE BORDER}

{*************************************}
{             INSTRUCTIONS            }
{ WRITES THE INSTRUCTIONS ON SCREEN   }
{ AND WAITS FOR USER INPUT            }
{*************************************}
PROCEDURE INSTRUCTIONS;
VAR K_PRESSED: CHAR; {DECLARES K_PRESSED}
BEGIN
     CLR_SCR; {CALLS CLR_SCR}
     BORDER(RED); {ADDS A RED BORDER}
     SETTEXTSTYLE(SANSSERIF_FONT, HORIZDIR,7); {CHANGES TEXT STYLE}
     SETCOLOR(LIGHTGREEN); {CHANGES COLOR}
     OUTTEXTXY(150,10,'Instructions'); {WRITES INSTRUCTIONS TO SCREEN}
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 6); {CHANGES TEXT STYLE}
     SETCOLOR(WHITE); {CHANGES COLOR}
     {WRITES INSTRUCTIONS TO SCREEN}
     OUTTEXTXY(10, 100, '1 | To Play, choose "Play Game" from main menu.');
     OUTTEXTXY(10, 140, '2 | Choose from the 3 difficulties, I can Win, Let Me at Em ');
     OUTTEXTXY(40, 155, 'and Nightmare.');
     OUTTEXTXY(10, 195, '3 | You Will be Prompted for you name, so enter it.');
     OUTTEXTXY(10, 235, '4 | You will then be asked 20 questions based on your difficulty,');
     OUTTEXTXY(40, 250, 'type your answer to the question. To exit Type "EXIT"');
     OUTTEXTXY(10, 290, '5 | You score is based on the difficulty and how fast you answer.');
     OUTTEXTXY(10, 330, '6 | If your score is higher then the current high scores,');
     OUTTEXTXY(40, 345, 'it will be added to the high score.');
     SETCOLOR(LIGHTRED); {CHANGES COLOR}
     OUTTEXTXY(10, 380, 'HAVE FUN PLAYING!'); {WRITES TO SCREEN}
     SETCOLOR(WHITE); {CHANGES COLOR}
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 4);  {CHANGES TEXT STYLE}
     OUTTEXTXY(250, 450, 'Press Space To Continue...'); {WRITES TO SCREEN}
     REPEAT
           K_PRESSED:= READKEY; {REPEATS UNTIL SPACE IS PRESSED}
     UNTIL K_PRESSED = CHR(32);
END;

{*************************************}
{             SPLASH_SCREEN           }
{ PRODUCES THE OPENING SCREEN OF THE  }
{ "PRODUCERS" , 21ST MILL GAMES       }
{*************************************}
PROCEDURE SPLASH_SCREEN(X_DELAY: INTEGER);
VAR X: INTEGER;
    {SPLASH_TEXT FUNCTION DETERMINS WHICH IS THE NEXT WORD TO OUTPUT}
    FUNCTION SPLASH_TEXT(A: INTEGER): STRING;
    BEGIN
         IF A = 1 THEN SPLASH_TEXT:= '21st'; {ASSIGNS '21ST' TO BE OUTPUT}
         IF A = 2 THEN SPLASH_TEXT:= 'Millenium'; {ASSIGNS 'MILLENIUM' TO BE OUTPUT}
         IF A = 3 THEN SPLASH_TEXT:= 'Games'; {ASSIGNS 'GAMES' TO BE OUTPUT}
         IF A = 4 THEN
            BEGIN
                 SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 10); {CHANGES THE TEXTSTYLE FOR LAST WORD}
                 SPLASH_TEXT:= '          Presents...'; {ASSIGNS 'PRESENTS' TO BE OUTPUT}
            END;
    END; {FUNCTION SPLASH_TEXT}
BEGIN
     CLR_SCR; {RUNS THE CLR_SCR PROCEDURE}
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR, 7); {CHANGES THE TEXT STYLE}
     SETCOLOR(GREEN); {SETS THE COLOR TO GREEN}
     FOR X:= 1 TO 4 DO
         BEGIN
              OUTTEXTXY (50, X*95, SPLASH_TEXT(X)); {OUTPUTS WORDS ON SCREEN}
              DELAY(X_DELAY); {WAITS X_DELAY AMOUNT OF MILLISENCONDS}
         END;
     DELAY(X_DELAY*3); {WAITS X_DELAY*3}
END; {SPLASH_SCREEN}

{*************************************}
{            DOOMSDAY_SCREEN          }
{ DISPLAYS THE GAMES SCREEN, WITH A   }
{ STAR ANIMATION AND DEVIL MAN        }
{*************************************}
PROCEDURE DOOMSDAY_SCREEN(X_DELAY, Y_DELAY, STAR_DELAY, HZ: INTEGER);
VAR X,Y: INTEGER;
    TEXT1, TEXT2: STRING[10]; {DECLARES TEXT1 AND 2 VARIABLES}
    {DEVIL_MAN PROCEDURE DRAWS A DEVIL MAN ON SCREEN}
    PROCEDURE DEVIL_MAN;
    BEGIN
         SETCOLOR(RED); {CHANGES COLOR TO RED}
         RECTANGLE(200,200,250,250); {DRAWS HEAD}
         LINE(200,200,200,180); {DRAWS HORNS}
         LINE(200,180,215,200); {DRAWS HORNS}
         LINE(250,250,250,180);
         LINE(250,180,235,200);
         RECTANGLE(220,250,230,400); {DRAWS BODY}
         LINE(220,400,200,430);  {DRAWS LEGS}
         LINE(230,400,250,430);
         CIRCLE(215,220,5);  {DRAWS EYES}
         CIRCLE(235,220,5);
         LINE(215,235,235,235); {DRAWS MOUTH}
         PUTPIXEL(214,236,RED); {TURNS EXPRESSION TO FROWN}
         PUTPIXEL(236,236,RED);
         RECTANGLE(180,280,310,290); {DRAWS ARMS}
         RECTANGLE(300,240,310,420); {DRAWS PITCHFORK}
         RECTANGLE(280,235,330,240);
         RECTANGLE(280,235,285,215);
         RECTANGLE(330,235,325,215);
         RECTANGLE(303,235,306,220);
    END;
BEGIN
     CLR_SCR; {CALLS CLR_SCR PROCEDURE}
     TEXT1:= 'DoomsDay'; {ASSIGNS TEXT1}
     TEXT2:= 'MATHS'; {ASSIGNS TEXT2}
     SETTEXTSTYLE(SANSSERIF_FONT, HORIZDIR, 7); {CHANGES TEXTSTYLE}
     SETCOLOR(LIGHTRED); {CHANGES COLOR TO LIGHT RED}
     FOR X:= 1 TO 8 DO
         BEGIN
              OUTTEXTXY(X*60, 40, TEXT1[X]); {OUTPUTS DOOMSDAY TO SCREEN, LETTER BY LETTER}
              SOUND(HZ); {PRODUCES SOUND IN HZ}
              DELAY(X_DELAY); {FOR X_DELAY MILLISECONDS}
              NOSOUND; {STOPS SOUND}
              DELAY(X_DELAY);
         END;
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR, 7); {CHANGES TEXTSTYLE}
     SETCOLOR(BLUE); {CHANGES COLOR TO BLUE}
     FOR
     Y:= 1 TO 5 DO
         BEGIN
              OUTTEXTXY(40,(Y*60)+50, TEXT2[Y]); {WRITE MATHS TO SCREEN, LETTER BY LETTER}
              SOUND(HZ); {PRODUCES SOUND IN HZ}
              DELAY(Y_DELAY); {FOR X_DELAY MILLISECONDS}
              NOSOUND; {STOPS SOUND}
              DELAY(Y_DELAY);
         END;
     DEVIL_MAN; {DRAWS DEVIL_MAN}
     SETCOLOR(WHITE); {SETS COLOR TO WHITE}
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 5); {CHANGES TEXT STYLE}
     {WRITES PRESS ANYKEY TO CONTINUE TO SCREEN}
     OUTTEXTXY((GETMAXX DIV 2) - 100, GETMAXY - 40, 'Press any key to continue...');
     {STARTS THE STAR_ANIMATION}
     STAR_ANIMATION(STAR_DELAY, WHITE, BLACK);
END; {PROCEDURE DOOMSDAY_SCREEN}

{*************************************}
{                CREDITS              }
{ PRODUCES THE CREDITS ON SCREEN WITH }
{ A SPARKLE ANIMATION UNTIL USER INPUT}
{*************************************}
PROCEDURE CREDITS(X_DELAY: INTEGER);
VAR X: INTEGER;
    {CREDIT_TEXT1 FUNCTION DEFINES WHAT TEXT IS NEXT TO BE OUTPUT}
    FUNCTION CREDIT_TEXT1(NO: INTEGER): STRING;
    BEGIN
         CASE NO OF
         1    : CREDIT_TEXT1:= 'Turbo Pascal 7.0'; {OUTPUTS TP70}
         2    : CREDIT_TEXT1:= 'Craig Sweetman'; {OUTPUTS CS}
         3    : CREDIT_TEXT1:= 'Craig Sweetman';
         4    : CREDIT_TEXT1:= 'Craig Sweetman';
         5    : CREDIT_TEXT1:= '1006 (EXACT)'; {OUTPUTS NUMBER}
         6    : CREDIT_TEXT1:= 'IntoThePit.Org (Pit Clan)';
         END;
    END;
    {CREDIT_TEXT2 FUNCTION DEFINES WHAT TEXT IS NEXT TO BE OUTPUT}
    FUNCTION CREDIT_TEXT2(NO: INTEGER): STRING;
    BEGIN
         CASE NO OF
         1    : CREDIT_TEXT2:= 'Compiled With: '; {OUTPUTS COMPILED WITH}
         2    : CREDIT_TEXT2:= 'Programmer: '; {OUTPUTS PROGRAMMER}
         3    : CREDIT_TEXT2:= 'Graphics: '; {OUTPUTS GRAPHICS}
         4    : CREDIT_TEXT2:= 'Sound'; {OUTPUTS SOUND}
         5    : CREDIT_TEXT2:= 'Lines Of Code: '; {OUTPUTS LINE OF CODE}
         6    : CREDIT_TEXT2:= 'Testing Team: ';
         END;
    END;
BEGIN
     CLR_SCR; {CALL CLR_SCR PROCEDURE}
     SETTEXTSTYLE(SANSSERIF_FONT, HORIZDIR, 2); {CHANGES THE TEXT STYLE}
     FOR X:= 1 TO 6 DO
         BEGIN
              SETCOLOR(RED); {CHANGES COLOR TO RED}
              OUTTEXTXY(30,X*60, CREDIT_TEXT2(X)); {OUTPUTS TEXT}
              SETCOLOR(WHITE); {CHANGES COLOR TO WHITE}
              OUTTEXTXY(400,X*60, CREDIT_TEXT1(X)); {OUTPUTS TEXT}
         END;
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 5); {CHANGES TEXT STYLE}
     SETCOLOR(WHITE); {CHANGES COLOR TO WHITE}
     OUTTEXTXY(200,450, 'Press Any Key To Continue...'); {WRITES PRESS A KEY TO SCREEN}
     REPEAT
           {FILL PIXELS IN RANDOM LOCATIONS IN RANDOM COLORS UNTIL A KEY IS PRESSED}
           PUTPIXEL(RANDOM(GETMAXX),RANDOM(GETMAXY), RANDOM(15));
           DELAY(X_DELAY);
     UNTIL KEYPRESSED; {EXITS WHEN A KEY IS PRESSED}
END; {PROCEDURE CREDITS}

{*************************************}
{         DIFFICULTY_SCREEN           }
{ PRODUCES MENU OF DIFFICULTIES, AND  }
{ WAITS TILL USER CHOOSES ONE, RETURNS}
{ THE VALUE OF WHICH DIFFICULTY WAS   }
{ CHOSEN.                             }
{*************************************}
FUNCTION DIFFICULTY_SCREEN: INTEGER;
VAR Y: INTEGER; {DECLARES Y PIXEL VARIABLE}
    K_PRESSED: CHAR; {DECLARES K_PRESSED VARIABLE}
    {WORDS FUNCTION RETURNS THE WORD TO BE OUTPUT ON SCREEN}
    FUNCTION WORDS(X: INTEGER): STRING;
    BEGIN
         IF X = 1 THEN WORDS:= '1 | I Can Win'; {IF X = 1 OUTPUT I CAN WIN}
         IF X = 2 THEN WORDS:= '2 | Let Me At ' + CHR(39) + 'Em'; {IF X = 2 OUTPUT LET ME AT 'EM}
         IF X = 3 THEN WORDS:= '3 | Nightmare!'; {IF X = 3 OUTPUT NIGHTMARE}
    END; {FUNCTION WORDS}
BEGIN
     CLR_SCR; {CALLS CLR_SCR PROCEDURE}
     SETFILLSTYLE(HATCHFILL, DARKGRAY); {CHANGES FILL STYLE}
     BAR((GETMAXX DIV 2) - 200, 50,(GETMAXX DIV 2)+ 200,GETMAXY -50); {PUTS A GRAY BAR ON THE SCREEN}
     SETCOLOR(RED);
     RECTANGLE((GETMAXX DIV 2) - 200, 50,(GETMAXX DIV 2)+ 200,GETMAXY -50); {PUTS A RED SQUARE ON THE SCREEN}
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR, 3); {CHANGES TEXT STYLE}
     FOR Y:= 1 TO 3 DO
         BEGIN
              SETFILLSTYLE(SOLIDFILL, BLACK); {CHANGES FILL STYLE}
              BAR ((GETMAXX DIV 2) - 120, Y*100, (GETMAXX DIV 2) + 120, (Y*100) + 50); {APPLIES A BAR}
              SETCOLOR(RED); {CHANGES COLOR TO RED}
              RECTANGLE((GETMAXX DIV 2) - 120, Y*100, (GETMAXX DIV 2) + 120, (Y*100) + 50); {DRAWS A RECTANGLE}
              SETCOLOR(WHITE); {CHANGES COLOR TO WHITE}
              OUTTEXTXY((GETMAXX DIV 2) - 100, (Y*100) + 2, WORDS(Y)); {OUTPUTS A WORD}
         END;
     REPEAT
           K_PRESSED:= READKEY; {REPEAT UNTIL 1,2 OR 3 IS PRESSED}
     UNTIL (K_PRESSED = CHR(50)) OR (K_PRESSED = CHR(49)) OR (K_PRESSED = CHR(51));
     CASE K_PRESSED OF
     CHR(49)        : DIFFICULTY_SCREEN:= EASY;
     CHR(50)        : DIFFICULTY_SCREEN:= MED;
     CHR(51)        : DIFFICULTY_SCREEN:= HARD;
     END;
END;{DIFFICULTY_SCREEN}

{*************************************}
{             GET_POS                 }
{ GETS THEIR PLACING IN THE TOP SCORES}
{*************************************}
FUNCTION GET_POS(NAME1: STRING; SCORE1: INTEGER): INTEGER;
VAR X: INTEGER;
BEGIN
     GET_SCORES;
     BUBBLE_SORT_SCORES;
     FOR X:= 1 TO 11 DO
         BEGIN {IF SCORES AND NAME MATCH, SAVE PLACE TO GET_POS}
              IF TOP_SCORES[X].NAME = NAME1 THEN
                 IF TOP_SCORES[X].SCORE = SCORE1 THEN GET_POS:= X;
         END;
END;

{*************************************}
{              GET_NAME               }
{ PRODUCES A "FORM" IN WHICH THE USER }
{ WILL ENTER THEIR NAME               }
{*************************************}
FUNCTION GET_NAME: STRING;
VAR TEMP: STRING; {DECLARES TEMP VARIABLE}
    X: INTEGER;
BEGIN
     CLR_SCR; {CALL CLR_SCR PROCEDURE}
     SETFILLSTYLE(HATCHFILL, DARKGRAY); {CHANGES FILLS STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-200, (GETMAXY DIV 2)-50, (GETMAXX DIV 2)+200, (GETMAXY DIV 2)+50);
     SETCOLOR(RED); {CHANGES COLOR}
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-200, (GETMAXY DIV 2)-50, (GETMAXX DIV 2)+200, (GETMAXY DIV 2)+50);
     SETFILLSTYLE(SOLIDFILL,BLACK); {CHANGES FILL STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-190, (GETMAXY DIV 2)-5,(GETMAXX DIV 2)-110,(GETMAXY DIV 2)+17);
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-190, (GETMAXY DIV 2)-5,(GETMAXX DIV 2)-110,(GETMAXY DIV 2)+17);
     SETCOLOR(GREEN); {CHANGES COLOR}
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR,2); {CHANGES TEXT STYLE}
     OUTTEXTXY((GETMAXX DIV 2)-180, (GETMAXY DIV 2)-7, 'Name '); {WRITES NAME TO SCREEN}
     SETFILLSTYLE(SOLIDFILL, BLACK); {CHANGES FILLS STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-100,(GETMAXY DIV 2)+17,(GETMAXX DIV 2)+100,(GETMAXY DIV 2)-5);
     SETCOLOR(RED);{CHANGES COLOR}
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-100,(GETMAXY DIV 2)+17,(GETMAXX DIV 2)+100,(GETMAXY DIV 2)-5);
     {MOVES CURSER TO 30,16}
     GOTOXY(30,16);
     TEXTCOLOR(WHITE); {CHANES TEXT COLOR FOR READLN}
     READLN(TEMP); {READS TEMP IN}
     GET_NAME:= TEMP; {ASSIGNS GET_NAME TO TEMP}
END;

{*************************************}
{             GET_PASSWORD            }
{ GETS THE PASSWORD FOR RESETING SCORS}
{*************************************}
FUNCTION GET_PASSWORD: STRING;
VAR TEMP: STRING; {DECLARES TEMP VARIABLE}
    X: INTEGER;
BEGIN
     CLR_SCR; {CALL CLR_SCR PROCEDURE}
     SETFILLSTYLE(HATCHFILL, DARKGRAY); {CHANGES FILLS STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-200, (GETMAXY DIV 2)-50, (GETMAXX DIV 2)+200, (GETMAXY DIV 2)+50);
     SETCOLOR(RED); {CHANGES COLOR}
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-200, (GETMAXY DIV 2)-50, (GETMAXX DIV 2)+200, (GETMAXY DIV 2)+50);
     SETFILLSTYLE(SOLIDFILL,BLACK); {CHANGES FILL STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-192, (GETMAXY DIV 2)-5,(GETMAXX DIV 2)-110,(GETMAXY DIV 2)+17);
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-192, (GETMAXY DIV 2)-5,(GETMAXX DIV 2)-110,(GETMAXY DIV 2)+17);
     SETCOLOR(LIGHTGREEN); {CHANGES COLOR}
     SETTEXTSTYLE(SANSSERIF_FONT, HORIZDIR,1); {CHANGES TEXT STYLE}
     OUTTEXTXY((GETMAXX DIV 2)-190, (GETMAXY DIV 2)-7, 'Password'); {WRITES PASSWORD TO SCREEN}
     SETFILLSTYLE(SOLIDFILL, BLACK); {CHANGES FILLS STYLE}
     {DRAWS BAR}
     BAR((GETMAXX DIV 2)-100,(GETMAXY DIV 2)+17,(GETMAXX DIV 2)+100,(GETMAXY DIV 2)-5);
     SETCOLOR(RED);{CHANGES COLOR}
     {DRAWS RECTANGLE}
     RECTANGLE((GETMAXX DIV 2)-100,(GETMAXY DIV 2)+17,(GETMAXX DIV 2)+100,(GETMAXY DIV 2)-5);
     {MOVES CURSER TO 30,16}
     GOTOXY(30,16);
     TEXTCOLOR(WHITE); {CHANES TEXT COLOR FOR READLN}
     READLN(TEMP); {READS TEMP IN}
     GET_PASSWORD:= TEMP; {ASSIGNS GET_PASSWORD TO TEMP}
END;


{*************************************}
{             GET_SCORES              }
{ READS THE TOP SCORES OUT OF A FILE  }
{*************************************}
PROCEDURE GET_SCORES;
VAR S_FILE: FILE OF SCORE_DETAILS; {DECLARES FILE OF SCORE RECORD}
    X: INTEGER;
BEGIN
     ASSIGN(S_FILE, S_PATH); {ASSIGNS THE FILE TO THE VARIABLE}
     RESET(S_FILE); {RESETS THE FILE FOR READING}
     FOR X:= 1 TO 11 DO
         READ(S_FILE, TOP_SCORES[X]); {READS ONE RECORD OUT AT A TIME}
     CLOSE(S_FILE); {CLOSES THE FILE}
END;

{*************************************}
{         BUBBLE_SORT_SCORES          }
{ BUBBLE SORTS THE SCORES...DAH       }
{*************************************}
PROCEDURE BUBBLE_SORT_SCORES;
VAR NOSWITCHES: BOOLEAN;
    I, PASS: INTEGER;
    TEMPA: INTEGER; TEMPB: STRING[10]; {DECLARES TEMPORARY VARIABLES}
BEGIN
     PASS:= 0; {NO PASSES HAVE BEEN MADE}
     REPEAT
           PASS:= PASS + 1; {1 EXTRA PASS HAS BEEN MADE}
           NOSWITCHES:= TRUE; {NO SWITHCES HAVE BEEN MADE}
           FOR I:= 1 TO 11 - PASS DO
               {IF I.SCORE IS SMALL THEN I+1.SCORE SWITCH VALUES}
               IF TOP_SCORES[I].SCORE < TOP_SCORES[I+1].SCORE THEN
                  BEGIN
                       NOSWITCHES:= FALSE; {A SWITCH HAS BEEN MADE}
                       TEMPA:= TOP_SCORES[I].SCORE; {SWITCH I WITH I+1}
                       TEMPB:= TOP_SCORES[I].NAME;
                       TOP_SCORES[I].NAME:= TOP_SCORES[I+1].NAME;
                       TOP_SCORES[I].SCORE:= TOP_SCORES[I+1].SCORE;
                       TOP_SCORES[I+1].NAME:= TEMPB;
                       TOP_SCORES[I+1].SCORE:= TEMPA;
                  END;
     UNTIL NOSWITCHES; {CONTINUE UNTIL NOSWITCHES WERE MADE}
END;

{*************************************}
{              SAVE_SCORES            }
{SAVES THE CURRENT TOP_SCORES 2 A FILE}
{*************************************}
PROCEDURE SAVE_SCORES;
VAR S_FILE: FILE OF SCORE_DETAILS; {DECLARE SCORE_DETAILS FILE VARIABLE}
    X: INTEGER;
BEGIN
     ASSIGN(S_FILE, S_PATH); {ASSIGN THE FILE TO THE VARIABLE}
     REWRITE(S_FILE); {OVERWRITE THE FILE}
     FOR X:= 1 TO 11 DO
         WRITE(S_FILE, TOP_SCORES[X]); {WRITE THE SCORE RECORD TO THE FILE}
     CLOSE(S_FILE); {CLOSE THE FILE}
END;

{*************************************}
{         HIGH_SCORES                 }
{ PRODUCES THE HIGH SCORES ON SCREEN, }
{ WAITS FOR USER TO PROCEED           }
{*************************************}
PROCEDURE HIGH_SCORES;
VAR X: INTEGER;
    SCORE: STRING;
    ENTER: CHAR; {DECLARES ENTER VARIABLE TO TELL IS ENTER IS PRESSED}
BEGIN
     CLR_SCR; {CALLS CLR_SCR PROCEDURE}
     GET_SCORES; {CALLS GET_SCORES PROCEDURE}
     BUBBLE_SORT_SCORES; {BUBBLE SORTS SCORES}
     SETTEXTSTYLE(GOTHIC_FONT, HORIZDIR, 7); {CHANGES THE TEXT STYLE}
     SETCOLOR(BLUE); {CHANGES COLOR TO BLUE}
     OUTTEXTXY(100,30, 'Top 10 Scores');{OUTPUTS TOP 10 SCORES}
     SETTEXTSTYLE(SANSSERIF_FONT, HORIZDIR, 3); {CHANGES TEXT STYLE}
     BORDER(DARKGRAY); {CALLLS BORDER PROCEDURE}
     FOR X:= 1 TO 10 DO
         BEGIN
              SETCOLOR(RED); {CHANGES COLOR}
              OUTTEXTXY(30,(X*30)+100,TOP_SCORES[X].NAME); {OUTPUTS NAME TO SCREEN}
              STR(TOP_SCORES[X].SCORE, SCORE); {CONVERTS SCORE TO STRING}
              SETCOLOR(GREEN); {CHANGES COLOR TO GREEN}
              OUTTEXTXY(400,(X*30)+100,SCORE); {OUTPUTS SCORE TO SCREEN}
              LINE(30,(X*30)+100,GETMAXX - 30, (X*30)+100); {DRAWS A LINE}
         END;
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 5); {CHANGES TEXT STYLE}
     SETCOLOR(WHITE); {CHANGES COLOR}
     DELAY(30); {DELAYS FOR 30 MILLISECOND}
     OUTTEXTXY(200,450, 'Press "Enter" Key To Continue...'); {OUTPUTS PRESS ENTER TO CONTINUE}
     REPEAT
           ENTER:= READKEY; {ASSIGNS ENTER TO A KEY THAT IS PRESSED}
     UNTIL ENTER = CHR(13); {WILL CONTINUE DOING SO UNTIL ENTER IS PRESSED}
END;

{*************************************}
{          SAVE_NEW_SCORES            }
{ SAVE A NEW SCORE TO [11] AND SAVES 2}
{ A FILE                              }
{*************************************}
PROCEDURE SAVE_NEW_SCORE(NAME1: STRING; SCORE1: INTEGER);
BEGIN
     GET_SCORES; {GETS SCORES FROM FILE}
     BUBBLE_SORT_SCORES; {SORTS SCORES}
     TOP_SCORES[11].NAME:= NAME1; {ADDS NEW NAME TO 11 IN ARRAY}
     TOP_SCORES[11].SCORE:= SCORE1; {ADDS NEW SCORE TO 11 IN ARRAY}
     BUBBLE_SORT_SCORES; {SORTS NEW SCORES}
     SAVE_SCORES; {SAVES SCORES}
END;

{*************************************}
{        SAVE_DEFAULT_SCORES          }
{ ASSIGNS DEFAULT NAMES AND SCORES AND}
{ SAVES TO FILE                       }
{*************************************}
PROCEDURE SAVE_DEFAULT_SCORES;
VAR X: INTEGER; {DECLARES X VARIABLE}
BEGIN
	TOP_SCORES[1].NAME:= '.net';   {ASSIGNS DEFAULT NAMES}
	TOP_SCORES[2].NAME:= 'Assassin';
	TOP_SCORES[3].NAME:= 'Spud';
	TOP_SCORES[4].NAME:= 'Sarge';
	TOP_SCORES[5].NAME:= 'Kikurass';
	TOP_SCORES[6].NAME:= 'Zeal';
	TOP_SCORES[7].NAME:= 'JoF';
	TOP_SCORES[8].NAME:= 'GreatBloke';
	TOP_SCORES[9].NAME:= 'Mr*B';
	TOP_SCORES[10].NAME:= 'Baldrick';
	TOP_SCORES[11].NAME:= 'Kamikazee';
        FOR X:= 1 TO 11 DO
            TOP_SCORES[X].SCORE := X; {ASSIGNS DEFAULT SCORES}
        SAVE_SCORES; {CALLS SAVE_SCORE PROCEDURE TO SAVE NEW SCORES}
END;

{*************************************}
{           VIEW_SCORE                }
{ DISPLAYS THE SCORE JUST ACHEIVED BY }
{ THE USER.                           }
{*************************************}
PROCEDURE VIEW_SCORE(SCORE: INTEGER; POS: STRING);
VAR K_PRESSED: CHAR; {DECLARES K_PRESSED}
    STR_SCORE: STRING; {DECLARES STRING SCORE}
BEGIN
     CLR_SCR; {CALLS CLR_SCR}
     BORDER(LIGHTRED); {ADDS A BORDER}
     SETCOLOR(GREEN); {CHANGES COLOR TO GREEN}
     SETTEXTSTYLE(GOTHIC_FONT, HORIZDIR, 8); {CHANGES TEXT STYLE}
     OUTTEXTXY(60,10,'Congratulations'); {WRITES CONGRATS TO SCREEN}
     SETCOLOR(LIGHTBLUE); {CHANGES COLOR}
     RECTANGLE(100,200,540,400); {DRAWS A RECTANGLE}
     SETCOLOR(LIGHTCYAN); {CHANGES COLOR}
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR,4); {CHANGES TEXT STYLE}
     STR(SCORE,STR_SCORE); {CONVERTS SCORE TO STRING}
     OUTTEXTXY(150,250,'Your Score is ' + STR_SCORE); {WRITES SCORE TO SCR}
     OUTTEXTXY(150,320,'You Placed ' + POS);
     SETCOLOR(WHITE); {CHANGES COLOR}
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 6); {CHANGES TEXT STYLE}
     OUTTEXTXY(220,420, 'Press Enter to Continue....'); {WRITE TO SCR}
     OUTTEXTXY(220,450, 'Press H to View High Scores...'); {WRITES TO SCR}
     REPEAT
           K_PRESSED:= READKEY; {REPEATS UNTIL H OR ENTER IS PRESSED}
     UNTIL (K_PRESSED = CHR(13)) OR (K_PRESSED = 'H') OR (K_PRESSED = 'h');
     IF (K_PRESSED = 'H') OR (K_PRESSED = 'h') THEN HIGH_SCORES; {IF H WAS PRESSED VIEWS HIGH SCORES}
END;

{*************************************}
{          GENERATE_QUESTIONS         }
{ GENERATES RANDOM QUESTIONS TO USE   }
{*************************************}
PROCEDURE GENERATE_QUESTIONS;
VAR A,B,C: INTEGER; {DECLARES NUMBER VARIABLES}
    TEMP1,TEMP2,TEMP3: STRING; {DECLARES STRING VARIABLES}
    X: INTEGER;
BEGIN
     RANDOMIZE;
     FOR X:= 1 TO 20 DO
         BEGIN
              A:= RANDOM(20); {GENERATES RANDOM NUMBER}
              B:= RANDOM(20);
              STR(A,TEMP1); {TURNS NUMBERS TO STRING}
              STR(B,TEMP2);
              EASY_Q[X].QUESTION:= TEMP1 + ' + ' + TEMP2; {CREATES QUESTION}
              EASY_Q[X].ANSWER:= A+B; {CREATES ANSWER}
         END;
     FOR X:= 1 TO 20 DO
         BEGIN
              A:= RANDOM(20); {GENERATES RANDOM NUMBER}
              B:= RANDOM(20);
              C:= RANDOM(20);
              STR(A,TEMP1); {TURNS NUMBER TO STRING}
              STR(B,TEMP2);
              STR(C,TEMP3);
              MED_Q[X].QUESTION:= TEMP1 + ' + ' + TEMP2 + ' + ' + TEMP3; {GENERATES Q'S}
              MED_Q[X].ANSWER:= A+B+C; {GENERATES ANSWERS}
         END;
     FOR X:= 1 TO 20 DO
         BEGIN
              A:= RANDOM(20); {GENERATES RANDOM NUMBERS}
              B:= RANDOM(20);
              C:= RANDOM(20);
              STR(A,TEMP1); {TURNS NUMBER TO STRING}
              STR(B,TEMP2);
              STR(C,TEMP3);
              {CREATES QUESTION}
              HARD_Q[X].QUESTION:= TEMP1 + ' x (' + TEMP2 + ' + ' + TEMP3 + ')';
              HARD_Q[X].ANSWER:= A*(B+C); {CREATES ANSWER}
         END;
END;

{*************************************}
{            ERROR_MESSAGE            }
{ GENERATES AN ERROR MESSAGE ON SCREEN}
{*************************************}
PROCEDURE ERROR_MESSAGE;
VAR K_PRESSED: CHAR;  {DECLARES K_PRESSED VARIABLE}
BEGIN
     CLR_SCR; {CALLS CLR_SCR PROCEUDRES}
     BORDER(RED); {ADDS A RED BORDER}
     SOUND(400); {PLAYS A SOUND AT 400HZ}
     SETCOLOR(RED); {CHANGES THE COLOR}
     SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR, 5); {CHANGES TEXT STYLE}
     OUTTEXTXY(30, 100, 'Invalid Input'); {WRITE INVALID INPUT TO SCREEN}
     DELAY(40); {DELAYS FOR 4O}
     SETCOLOR(WHITE); {CHANGES COLOR}
     SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 7); {CHANGES TEXT STYLE}
     OUTTEXTXY(300,300, 'PRESS "SPACE" TO CONTINUE'); {WRITES TO SCREEN}
     NOSOUND; {STOPS THE SOUND}
     REPEAT
           K_PRESSED:= READKEY;
     UNTIL K_PRESSED= CHR(32); {REPEATS UNTIL SPACE IS PRESSED}
END;

{*************************************}
{         ASK_QUESTION                }
{ ASK THE QUESTION, AND DETERMINS THE }
{ SCORE, IF NOT A NUMERICAL ANSWER, OR}
{ NO ANSWER, DISPLAYS ERROR MESSAGE,  }
{ RETURNS THE SCORE FOR THE QUESTION  }
{ ASKED                               }
{*************************************}
FUNCTION ASK_QUESTION(QUESTION: STRING; ANSWER: INTEGER; DIFF, CUR_SKR: INTEGER): INTEGER;
VAR USR_ANSWER: STRING; {DECLARES USER ANSWER VARIABLE}
    SCORE: INTEGER; {DECLARES SCORE}
    STR_SCORE:STRING; {DECLARES STRING SCORE}
    HR1,MIN1,SEC1,SEC110: WORD; {DECLARES TIME VARIABLES}
    HR2,MIN2,SEC2,SEC210: WORD; {DECLARES SECONDT TIME VAR}
    FHR,FMIN,FSEC: WORD; {DECLARES FINAL TIME VAR}
    SECONDS: INTEGER; {DECLARES SECONDS}
    STR_ANSWER: STRING; {DECLARES STRING ANSWER}
         {COMPARE_STR FUNCTION TESTS IF THEIR IS ANY NON NUMBERICAL VALUES PRESENT}
         FUNCTION COMPARE_STR(U_ANSWER: STRING): BOOLEAN;
         VAR X,Y: INTEGER;
             FULL_ALPHA: STRING;
         CONST ALPHA_SHIFT = '!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:"?><MNBVCXZ~';
               ALPHA = ' -=qwertyuiop[]\;lkjhgfdsazxcvbnm,./`' + CHR(39);
         BEGIN
              FULL_ALPHA:= ALPHA + ALPHA_SHIFT;
              IF U_ANSWER = 'EXIT' THEN {CHECKS IF USER TYPED EXIT}
                          COMPARE_STR:= TRUE
              ELSE
              BEGIN
                   FOR X:= 1 TO LENGTH(U_ANSWER) DO
                       FOR Y:= 1 TO LENGTH(FULL_ALPHA) DO
                          {CHECKS IF ANY PRESENT}
                           IF U_ANSWER[X] = FULL_ALPHA[Y] THEN COMPARE_STR:= FALSE;
              END;
         END;
BEGIN
     REPEAT
           CLR_SCR; {CLEARS THE SCREEN}
           BORDER(BLUE); {ADDS A BORDER}
           SETCOLOR(GREEN); {SETS THE COLOR}
           RECTANGLE(100,100,540,200); {DRAWS A RECTANGLE}
           SETTEXTSTYLE(SMALL_FONT, HORIZDIR, 9); {CHANGES THE FONT}
           SETCOLOR(WHITE); {CHANGES THE COLOR}
           OUTTEXTXY(130,130, 'Question:'); {WRITES QUESTION TO SCREEN}
           OUTTEXTXY(290,130, QUESTION); {WRITES THE QUESTION TO SCREEN}
           SETCOLOR(GREEN); {CHANGES THE COLOR}
           RECTANGLE(100,250,540,350); {DRAWS A RECTANGLE}
           SETCOLOR(WHITE); {CHANGES THE COLOR}
           OUTTEXTXY(130,280, 'Answer:'); {WRITES ANSWER TO SCREEN}
           SETCOLOR(BLUE); {CHANGES COLOR}
           STR(CUR_SKR,STR_SCORE); {CONVERS SCORE TO STRING}
           OUTTEXTXY ((GETMAXX DIV 2)-100,GETMAXY -50, 'SCORE: ' + STR_SCORE); {WRITES SCORE TO SCREEN}
           GOTOXY(40,19); {MOVES CURSER TO 40,19}
           TEXTCOLOR(WHITE); {CHANGES TEXT COLOR}
           GETTIME(HR1,MIN1,SEC1,SEC110); {GETS THE CURRENT TIME}
           READLN(USR_ANSWER); {GETS THE ANSWER}
           GETTIME(HR2,MIN2,SEC2,SEC210); {GETS THE CURRENT TIME}
           IF NOT COMPARE_STR(USR_ANSWER) THEN ERROR_MESSAGE; {COMPARS FOR NUMERICALS}
           IF LENGTH(USR_ANSWER) = 0 THEN ERROR_MESSAGE; {IF NO ANSWER ERROR MESSAGE}
     UNTIL (COMPARE_STR(USR_ANSWER)) AND (LENGTH(USR_ANSWER) <> 0); {REPEATS UNTIL ONLY NUMERICALS PRESENT}
     FHR:= HR2 - HR1;   {CALCULATES HOW MANY SECONDS ELAPSED WHILE ANSWERING}
     FMIN:= MIN2 - MIN1;
     FSEC:= SEC2 - SEC1;
     IF USR_ANSWER = 'EXIT' THEN {IF USER TYPED EXIT}
        BEGIN
             ASK_QUESTION:= 1337; {SCORE BECOMES ELLITE}
             EXIT; {EXITS FUNCTION}
        END;
     IF USR_ANSWER = '11203' THEN {IF ANSWER = CHEAT THEN BONUS POINTS}
        BEGIN
             ASK_QUESTION:= 1000; {POITNS IS 1000 FOR CHEATS}
             EXIT; {EXIT}
        END;
     SECONDS:= ((FHR*60)*60) + (FMIN*60) + FSEC;
     STR(ANSWER,STR_ANSWER);
     IF USR_ANSWER = STR_ANSWER THEN {CHECKS IF ANSWER IS CORRECT}
        BEGIN
             IF DIFF = EASY THEN SCORE:= 20; {CALCULATES THE SCORE APPROPIRATLY}
             IF DIFF = MED THEN SCORE:= 50;
             IF DIFF = HARD THEN SCORE:= 100;
             IF (SECONDS < 60) AND (SECONDS > 0) THEN {IF ANSWERED WITHIN A MINUTE, BONUS POINTS}
                    ASK_QUESTION:= SCORE + (60 - SECONDS)
                ELSE
                    ASK_QUESTION:= SCORE;
        END;
     IF USR_ANSWER <> STR_ANSWER THEN ASK_QUESTION:= 0; {IF ANSWER IS WRONG, NO POINTS}
END;

{*************************************}
{                  GAME               }
{GETS THE DIFFICULTY AND NAME, AND    }
{PRODUCES THE QUESTIONS TO ASK,       }
{IT ADDS THE SCORE TO THE HIGH SCORES }
{AND SAVES THEM                       }
{*************************************}
PROCEDURE GAME;
VAR DIFFICULTY: INTEGER; {DECLARES DIFFICULTY}
    SCORE,NEW_SCORE: INTEGER; {DECLARES SCORES}
    NAME: STRING; {DECLARES NAME}
    X: INTEGER;
    POS: STRING;
BEGIN
     NEW_SCORE:= 0; {NEW SCORE IS 0}
     GENERATE_QUESTIONS; {GENERATES QUESTIONS}
     DIFFICULTY:= DIFFICULTY_SCREEN; {CALL DIFFICULTY_SCREEN}
     NAME:= GET_NAME; {CALL GET_NAME SCREEN}
     IF NAME = 'EXIT' THEN EXIT; {EXITS GAME}
     IF DIFFICULTY = EASY THEN {IF EASY DIFFICULTY}
        BEGIN
             FOR X:= 1 TO 20 DO
                 BEGIN
                 {ASK QUESTIONS, ADD THE SCORES}
                 SCORE:= ASK_QUESTION(EASY_Q[X].QUESTION,EASY_Q[X].ANSWER,DIFFICULTY,NEW_SCORE);
                 NEW_SCORE:= NEW_SCORE + SCORE; {ADDS SCORE}
                 IF SCORE = 1337 THEN EXIT;
                 END;
        END;
     IF DIFFICULTY = MED THEN {IF MEDIUM}
        BEGIN
             FOR X:= 1 TO 20 DO
                 BEGIN
                 {ASK QUESTIONS, ADD THE SCORES}
                 SCORE:= ASK_QUESTION(MED_Q[X].QUESTION,MED_Q[X].ANSWER,DIFFICULTY,NEW_SCORE);
                 NEW_SCORE:= NEW_SCORE + SCORE; {ADDS SCORE}
                 IF SCORE = 1337 THEN EXIT;
                 END;
        END;
     IF DIFFICULTY = HARD THEN {IF HARD}
        BEGIN
             FOR X:= 1 TO 20 DO
                 BEGIN
                 {ASK QUESTIONS AND GET SCORE}
                 SCORE:= ASK_QUESTION(HARD_Q[X].QUESTION,HARD_Q[X].ANSWER,DIFFICULTY,NEW_SCORE);
                 NEW_SCORE:= NEW_SCORE + SCORE; {ADD SCORE}
                 IF SCORE = 1337 THEN EXIT; {IF EXITCODE PROCUDED EXIT}
                 END;
        END;
     SAVE_NEW_SCORE(NAME, NEW_SCORE); {SAVES THE SCORE}
     BUBBLE_SORT_SCORES;
     CASE GET_POS(NAME, NEW_SCORE) OF
     1   : POS:= '1st'; {DETERMINS WHAT PLACE YOU GET}
     2   : POS:= '2nd';
     3   : POS:= '3rd';
     4   : POS:= '4th';
     5   : POS:= '5th';
     6   : POS:= '6th';
     7   : POS:= '7th';
     8   : POS:= '8th';
     9   : POS:= '9th';
     10  : POS:= '10th';
     11  : POS:= '11th';
     END;
     DELAY(1000); {DELAYS}
     VIEW_SCORE(NEW_SCORE,POS); {DISPLAYS THE ENDIGN SCREEN OF THE SCORE}
END;

{*************************************}
{             RESET_SCORES            }
{ RESETS THE SCORE TO DEFAULT, AND THE}
{ RESETING OF THE SCORES IS PASSWORD  }
{ PROTECTED                           }
{*************************************}
PROCEDURE RESET_SCORES;
VAR PASS: STRING;  {DECLARES PASS}
BEGIN
     REPEAT
           PASS:= GET_PASSWORD; {GETS PASSWORD}
           IF PASS = 'EXIT' THEN EXIT; {EXITS IF EXIT TYPE}
           IF PASS <> 'IntoThePit.Org' THEN ERROR_MESSAGE; {ERROR MESSAGE}
           {THE ONLY OTHER WAY TO RESET THE SCORES IS TO USE}
           {A PASSWORD OR DELETE THE SCORES FILE ITSELF     }
     UNTIL PASS = 'IntoThePit.Org'; {PASSWORD}
     SAVE_DEFAULT_SCORES; {RESETS SCORES}
END;


{*************************************}
{            MAIN_MENU                }
{ DISPLAYS THE MAIN MENU ON SCREEN AND}
{ WAITS FOR THE USER TO DECIDE, AND   }
{ FOLLOWS THE CHOICE GIVE             }
{*************************************}
PROCEDURE MAIN_MENU;
VAR X: INTEGER;
    K_PRESSED: CHAR; {DECLARES K_PRESSED VARIABLE}
    {MENU_TEXT FUNCTION DETERMINES WHAT LINE WILL BE OUTPUT}
    FUNCTION MENU_TEXT(Y: INTEGER): STRING;
    BEGIN
         CASE Y OF
         1    : MENU_TEXT:= '1 | Play Game'; {PLAY WILL BE OUTPUT}
         2    : MENU_TEXT:= '2 | Instructions'; {INSTRUCTION WILL BE OUTPUT}
         3    : MENU_TEXT:= '3 | High Scores'; {HIGH SCORES OUTPUT}
         4    : MENU_TEXT:= '4 | Reset Scores'; {RESET SCORES OUTPUT}
         5    : MENU_TEXT:= '5 | Exit'; {EXIT WILL BE OUTPUT}
         END;
    END;
BEGIN
     REPEAT
           CLR_SCR; {CALLS CLR_SCR PROCEDURE}
           BORDER(GREEN); {ADDS A GREEN BORDER}
           SETTEXTSTYLE(TRIPLEX_FONT, HORIZDIR,8); {CHANGES TEXT STYLE}
           SETCOLOR(WHITE); {CHANGES COLOR}
           OUTTEXTXY(120,10,'DoomsDay'); {ADDS DOOMSDAY TO SCREEN}
           OUTTEXTXY(180,390,'MATHS'); {ADDS MATHS TO SCREEN}
           SETTEXTSTYLE(SANSSERIF_FONT,HORIZDIR,4); {CHANGES TEXT STYLE}
           SETCOLOR(BLUE); {CHANGES COLOR}
           FOR X:= 1 TO 5 DO
               OUTTEXTXY((GETMAXX DIV 2) - 140, (X*40) + 100,MENU_TEXT(X)); {WRITES TEXT TO SCREEN}
           K_PRESSED:= READKEY; {GETS THE KEY THAT IS PRESSED}
           CASE K_PRESSED OF
           '1'    : GAME; {CALLS GAME PROCEDURE}
           '2'    : INSTRUCTIONS; {CALLLS INSTRUCTIONS}
           '3'    : HIGH_SCORES; {CALLS HIGH SCORES PROCEDURE}
           '4'    : RESET_SCORES; {CALLS SAVE DEFAULTS PROCEDURE}
           END;
     UNTIL K_PRESSED = '5'; {UNTIL 5 (EXIT) IS PRESSED}
     CREDITS(13); {CALLS THE CREDITS PROCEDURE}
END;

{*************************************}
{                BODY                 }
{ DERMINES IF SCORE FILE EXITS IF IT  }
{ DOESNT CREATES IT, AND DISPLAYS OPEN}
{ SCREENS AND MAIN MENU               }
{*************************************}
BEGIN
     GRDRIVER:= DETECT;
     INITGRAPH(GRMODE, GRDRIVER, G_PATH);
     MKDIR('SCORES'); {MAKES SCORES DIRECTORY}
     IF IORESULT = 0 THEN SAVE_DEFAULT_SCORES; {IF DIRECTORY NOT EXISTS, CREATE SCORE FILE}
     DELAY(100); {DELAYS}
     SPLASH_SCREEN(200); {CALLS SPLASH_SCREEN}
     DOOMSDAY_SCREEN(100,80,3,400); {CALLS DOOMSDAY_SCREEN}
     MAIN_MENU; {DISPLAYS MAIN_MENU}
     {END OF GAME}
END.
